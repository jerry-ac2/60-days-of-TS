/**
 * retryAsync: Wraps an async function with retry + exponential backoff.
 *
 * Usage:
 *   const safeFetch = retryAsync(fetchJson, { retries: 4, delay: 200, factor: 1.5 });
 *   await safeFetch(url);
 *
 * @template A extends any[], R
 * @param fn - async function to wrap
 * @param opts - options:
 *   retries: number of retry attempts (default 3)
 *   delay: initial delay in ms between attempts (default 100)
 *   factor: multiplier for exponential backoff (default 2)
 *   shouldRetry: (err) => boolean to decide retry (default: always true)
 * @returns wrapped function with same signature as fn
 */
export function retryAsync<A extends any[], R>(
  fn: (...args: A) => Promise<R>,
  opts?: {
    retries?: number;
    delay?: number;
    factor?: number;
    shouldRetry?: (err: any) => boolean;
  }
): (...args: A) => Promise<R> {
  const { retries = 3, delay = 100, factor = 2, shouldRetry = () => true } = opts || {};
  const sleep = (ms: number) => new Promise(res => setTimeout(res, ms));
  return async (...args: A): Promise<R> => {
    let attempt = 0;
    let wait = delay;
    while (true) {
      try {
        return await fn(...args);
      } catch (err) {
        if (attempt >= retries || !shouldRetry(err)) throw err;
        await sleep(wait);
        wait = Math.max(0, wait * factor);
        attempt++;
      }
    }
  };
}